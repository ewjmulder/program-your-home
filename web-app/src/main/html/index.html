<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width initial-scale=1.0 maximum-scale=1.0 user-scalable=yes" />
		<title>Program You Home - Web App</title>
		<link rel="stylesheet" type="text/css" href="css/pyh.css" />
<!-- TODO: Do we really need this for anything? Default text-shadow is annoying. Yes we do, see side scrolling behavior otherwise.
So question remains how to disable the text-shadow.
For now, just hacked out. TOOD: choose new ui theme without text-shadow. -->
		<link rel="stylesheet" type="text/css" href="css/jquery.mobile.custom.structure.min.css" />
		<link rel="stylesheet" type="text/css" href="css/jquery.mobile.custom.theme.min.css" />
 		<link rel="stylesheet" type="text/css" href="css/jquery.mmenu.all.css" />
		<script type="text/javascript" src="js/jquery-2.1.1.min.js"></script>
		<script type="text/javascript" src="js/jquery.mobile.custom.min.js"></script>
		<script type="text/javascript" src="js/jquery.mmenu.min.all.js"></script>
		<script type="text/javascript" src="js/jquery.rest.js"></script>
		<script type="text/javascript" src="js/handlebars-v3.0.1.js"></script>
		<!-- TODO: put functions in sep javascript file + split util and pyh specific functions, only keep body-onload and vars in main file -->
		<script type="text/javascript">
			// TODO: The server can provide a list of activated modules and the UI can enable/disable pages based on that info.
			var Page = function (name, templateName, restApiBase) {
				this.name = name;
				this.templateName = templateName;
				this.usesRestApi = function () { return restApiBase != null; };
				if (restApiBase != null) {
					this.restApiFunction = function () { return restApiBase.read(); };
				}
			};
			var Pages;
			var templates = {};
			var templateNames;
			var currentPage;
			// TODO: make into a map of some sort with page.id or so as key
			var restClientMain;
			var restClientHue;
			var restClientIr;
			
			var restApiDoneFunction = function (result) {
				if (result.success) {
					refreshCurrentPage();
				} else {
					showError("REST API call returned an error: " + result.error);
				}
			};
			var restApiFailFunction = function (jqXHR, status, error) {
				if (error == "") {
					showError("REST API could not be reached.");					
				} else {
					showError("REST API call failed with error: " + error);
				}
			};
			var restApiResponseFunction = function (arg1, status, arg2) {
				if (status == "success") {
					restApiDoneFunction(arg1, status, arg2);
				} else if (status == "error" || status == "parsererror") {
					restApiFailFunction(arg1, status, arg2);				
				} else {
					// TODO: all known status texts: ("success", "notmodified", "nocontent", "error", "timeout", "abort" or "parsererror")
					showError("Unknown REST API response status: ''" + status + "'.");
				}
			};
			
			$(document).ready(function () {				
				// TODO: note to self: double nested requires ID for the first!
				// So my REST service starts at /main /hue etc, which makes sense indeed, sep rest services for these URL's
				// furthermore, the rest plugin really forces using the REST api, so get ready to reastify :)
				// (probably fine to support both full rest and getters along the way. (or just use rest where I can use it and
				// use simple wget style stuff to activate activities / press buttons etc)

				// Take the same server on port 3737 as base URL for the Program Your Home server.
				
				// Search after the 'http://' part (length 7), find the first colon or slash from there gives us our base URL.
				var indexOfColon = window.location.href.indexOf(":", 7);
				var indexOfSlash = window.location.href.indexOf("/", 7);
				var sliceIndex = indexOfColon > -1 ? indexOfColon : indexOfSlash;
				var baseURL = window.location.href.slice(0, sliceIndex) + ":3737/";
				
				restClientMain = new $.RestClient(baseURL + "main/");
				restClientMain.add("activities");
				restClientMain.activities.addVerb("start", "GET");
				restClientMain.activities.addVerb("stop", "GET");

				restClientHue = new $.RestClient(baseURL + "hue/");
				restClientHue.add("lights");
				restClientHue.lights.addVerb("on", "GET");
				restClientHue.lights.addVerb("off", "GET");

				restClientIr = new $.RestClient(baseURL + "ir/");
				restClientIr.add("devices");
				
				Pages = Object.freeze({
					ACTIVITIES: new Page("activities", "activities", restClientMain.activities),
					LIGHTS: new Page("lights", "lights", restClientHue.lights),
					DEVICES: new Page("devices", "devices", restClientIr.devices),
					ABOUT: new Page("about", "about", null)
				});
				function pageNames(types) {
					return Object.keys(types).map(function (type) {
				    	return types[type].name;
					});
				};
				templateNames = pageNames(Pages);
				currentPage = Pages.ACTIVITIES;
				
				restClientIr.devices.read().done(function (devices) {
					// TODO: use template for menu stuff and some way to configure all menu preloading that needs to be done.
					// Furthermore: you might want to add class="ui-link" to the <a>, that is done somewhere (in jquery (ui)) already for the other <a>'s.
					var devicesMenuHtmlString = "";
					devicesMenuHtmlString += "<ul>";
					for (var i = 0; i < devices.length; i++) {
						var device = devices[i];
						devicesMenuHtmlString += "<li><a href='#'>" + device.name + "</a></li>";
					}
					devicesMenuHtmlString += "</ul>";
					$("#menu-devices").after(devicesMenuHtmlString);
					
					//TODO: put mmenu-ing in sep function and call that when all menu-preloading is done.
					//TODO: Use iconbar extension? (http://mmenu.frebsite.nl/documentation/extensions/iconbar.html)
					$("#menu").mmenu({
						offCanvas	: true,
						extensions	: ["theme-dark"],
						header		: {
							add			: true,
							update		: true,
							title		: 'Menu'
						}
					});

					//var menuApi = $("#menu").data("mmenu");
					//menuApi.open();

				});

				var numberOfTemplatesLoaded = 0;
				templateNames.forEach(function (templateName) {
					// TODO: error handling when templates not found or could not be parsed
				    $.get("/templates/" + templateName + ".hbs.html", function (contents) {
				    	templates[templateName] = Handlebars.compile(contents);
				    	numberOfTemplatesLoaded++;
				    	// If all templates have been loaded, start loading the actual page contents.
				    	if (numberOfTemplatesLoaded == templateNames.length) {
				    		refreshCurrentPage();
				    		// Refresh every so often to keep in sync with server state.
				    		// TODO: Alternative to reload every second: have websocket connection to server
				    		// and reload only upon receiving a changed event (and ideally only if change is on current page)
			                setInterval(function () {
					    		refreshCurrentPage();
			                }, 1000);
				    	}
				    });
				});
			});
			function showError(errorMessage) {
				// TODO: nicer error 'popup'. -> use mmenu or some other nice jQuery solution
				alert("Error occured: " + errorMessage);
			};
			function toggleActivity(id, currentlyActive) {
				if (currentlyActive) {
					restClientMain.activities.stop(id).always(restApiResponseFunction);					
				} else {
					restClientMain.activities.start(id).always(restApiResponseFunction);
				}
			};
			function toggleLight(id, currentlyOn) {
				if (currentlyOn) {
					restClientHue.lights.off(id).always(restApiResponseFunction);					
				} else {
					restClientHue.lights.on(id).always(restApiResponseFunction);
				}
			};
			function loadPage(page) {
				currentPage = page;
				refreshCurrentPage();
			};
			function refreshCurrentPage() {
				if (currentPage.usesRestApi()) {
					currentPage.restApiFunction().done(function (data) {
						setContentWithTemplate(currentPage.templateName, createTemplateDataFromCurrentPage(data));
					})
					.fail(restApiFailFunction);
				} else {
					//TODO: how to provide data input? -> for now just no data required (to be: static template page)
					setContentWithTemplate(currentPage.templateName, {});
				}
			};
			function createTemplateDataFromCurrentPage(data) {
				var templateData = {};
				// Use the template name as property name to feed the template with.
				templateData[currentPage.name] = data; 
				return templateData;
			};
			function setContentWithTemplate(templateName, templateData) {
		    	var contentHtml = templates[templateName](templateData);
	    		$("#content").html(contentHtml);
			};
		</script>
	</head>
	<body>
		<div id="page">
			<div class="header">
				<a href="#menu"></a>
				Program Your Home
			</div>
			<div id="content" class="content">
				Loading content...
			</div>
		</div>
		<!-- href='#' will have default behavior blocked! -->
		<nav id="menu">
			<ul>
			<!--  TODO: always build this dynamically based on the pages. <li> part should be a template - can't we inline these small templates? -->
				<li id="menu-activities"><a href="#" onclick="loadPage(Pages.ACTIVITIES)">Activities</a></li>
				<li id="menu-lights"><a href="#" onclick="loadPage(Pages.LIGHTS)">Lights</a></li>
				<li id="menu-devices"><a href="#" onclick="loadPage(Pages.DEVICES)">Devices</a></li>
				<li id="menu-about"><a href="#" onclick="loadPage(Pages.ABOUT)">About</a></li>
			</ul>
		</nav>
	</body>
</html>